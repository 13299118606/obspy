Structure of the program when calling TauP_Create. Remember names starting with uppercase are classes. 

TauP_Create:
    __init__:
        PropertyLoader
        OR if unsuccessful uses inbuilt Properties()
        
    main:
        loadVMod
        start
        
    loadVMod:
        call either VelocityModel.readVelocityFile
        or if that didn't work:
        TauModelLoader.loadVelocityModel #for previously read model I think
        (may call VelocityModel.replaceLayers btw)
        
    start:
        tMod = createTauModel(vMod) #returns an instance of TauModel
        set an outfile filename and
        self.tMod.writeModel(outFile)
    
    createTauModel:
        self.sMod = SphericalSModel(vMod, ... (sneaky call to a 
        SlownessModel class default value)) 
        return TauModel(self.sMod)
        
PropertyLoader:
    finds taup.jar, reads a config file (called properties here)
    
SphericalSModel extends SlownessModel:
    There are three constructors; the middle one is called here, as
    createTauModel passes 7 arguments after vmod. If only vmod was supplied, the 
    first constructor would call the middle one with some default 
    arguments. The middle constructor calls its superclass (i.e. SlownessModel) 
    constructor with super()!

    interpolate method is defined here (only abstract in SlownessModel)
    toSlownessLayer (also abstract in superclass)
        returns new SlownessLayer instance
    toSlowness, toVelocity also defined here
        
TauModel:   
    # doesn't want to be translated by j2py!
    has 2 constructors, I believe the first is called (1 argument); however it
    assumes the input to be a SlownessModel, NOT the SphericalSModel it is 
    given. Probably works because latter is subclass of the former.
    In the constructor:
        calcTauIncFrom();
        
    calcTauIncFrom():
        # calculates tau for each branch
        # sMod refers now to Slowness-, not SphericalSModel
        sMod.validate()
        sMod.getRadiusOfEarth()
        sMod.getNumCriticalDepths()
        TauBranch   #called with: new TauBranch[some int], filled in later
        sMod.getSlownessLayer
            returns a SlownessLayer object
        SlownessLayer.getTopP  (implicitly. also BotP of course)
        sMod.getNumLayers
        sMod.getCriticalDepth.getLayerNum
        sMod.vMod.getMohoDepth etc, where vMod was given to sMod as a param

    writeModel:
        called by TauP_Create to write to file; looks simple

SlownessLayer:
        calls on VelocityLayer
        remove, add, get top/btm depths etc
        
SlownessModel:
    The first constructor is called from SphericalSModel.
        calls createSample()

    createSample()
        vMod.validate
        vMod.getNumLayers
        vMod.getVelocityLayer(0).getTopSVelocity()
        findCriticalPoints
        coarseSample
        rayParamIncCheck
        depthIncCheck
        distanceCheck
        fixCriticalPoints
        also calls validate if DEBUG
    
    findCriticalPoints
        DepthRange
        CriticalDepth
        
        findDepth
        toSlownessLayer

        vMod.getVelocityLayerClone
        currVLayer.getTopDepth (this is a VelocityLayer method)        
        getTopP (SlownessLayer method)        

        criticalDepths.add   (methods of CriticalDepth)
        criticalDepths.clear()

        highSlownessLayerDepthsP.clear()  (instances (so methods) of DepthRange)
        highSlownessLayerDepthsS.add
        fluidLayerDepths.clear()  
        highSlownessLayerDepthsP.size
        highSlownessLayerDepthsP.get(layerNum)
        
        
                
    findDepth
        some vMod/Layer methods
        toSlowness
        interpolate
        depthInFluid

    interpolate
        Here, it's only an abstract method: no implementation is provided (body 
        of method is empty). However, subclasses must provide an implementation; 
        this is done in SphericalSModel. Not sure how this class knows about its 
        subclass though...        

    toSlownessLayer
        also an abstract method.
        replaced (by me) by SlownessLayer.create_from_vlayer 
          
    coarseSample
        some vlayer, slayer methods and PLayers.clear, where PLayers is simply a 
        list of SlownessLayers, screwing up the nomenclature
        depthInFluid
        addSlowness
    
    depthInFluid
    addSlowness
    rayParamIncCheck
    depthIncCheck
        toSlowness
    toSlowness
        is abstract, def'd in SphericalSModel
    distanceCheck
        uses TimeDist
        getSlownessLayer
        depthInHighSlowness
        approxDistance
    getSlownessLayer
    depthInHighSlowness
        DepthRange.rayParam    
    approxDistance
        getNumLayers    
    fixCriticalPoints
    getNumLayers
    validate:
            DepthRange
            DepthRange.size     # via highSlownessLayerDepths.size
            DepthRange.get
            DepthRange.get.topDepth     # and bot
            getSlownessLayer.validate, .getTopDepth, .getBotP etc}
    not needed (?)
    
CriticalDepth:            
    very simple.

DepthRange:
    clear, add, size, rayParam
    
TimeDist ('implements cloneable')
    simples. maybe combine some of these really short classes?
    add, time, distRadian
TauBranch:
    nothing special in the constructors.
